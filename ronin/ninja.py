
from .contexts import current_context
from .phases import Phase
from .projects import Project
from .utils.paths import join_path, change_extension
from .utils.strings import stringify
from .utils.platform import which
from .utils.collections import dedup
from .utils.types import verify_type
from cStringIO import StringIO
from os import makedirs
from subprocess import check_call, CalledProcessError
from datetime import datetime
from textwrap import wrap
import sys, os

# See:
# https://ninja-build.org/manual.html#_ninja_file_reference
# https://github.com/ninja-build/ninja/blob/master/misc/ninja_syntax.py

DEFAULT_NAME = 'build.ninja'
DEFAULT_COLUMNS = 100

def configure_ninja(command=None, file_name=None, columns=None, strict=None):
    with current_context(False) as ctx:
        ctx.ninja_command = command
        ctx.ninja_file_name = file_name
        ctx.ninja_file_columns = columns
        ctx.ninja_file_strict = strict

class NinjaFile(object):
    """
    Manages a `Ninja build system <https://ninja-build.org/>`__ file.
    """
    
    def __init__(self, project, command=None, file_name=None, columns=None, strict=None):
        verify_type(project, Project)
        self._project = project
        self.command = None
        self.file_name = file_name
        self.columns = None
        self.strict = None
    
    def __str__(self):
        io = StringIO()
        try:
            self.write(io)
            v = io.getvalue()
        finally:
            io.close()
        return v
    
    @property
    def base_path(self):
        with current_context() as ctx:
            return join_path(ctx.output_path, self._project.variant)

    @property
    def path(self):
        with current_context() as ctx:
            file_name = stringify(ctx.fallback(self.file_name, 'ninja_file_name', DEFAULT_NAME))
        return join_path(self.base_path, file_name)

    def generate(self):
        base_path = self.base_path
        path = self.path
        print "ronin: Generating '%s'" % path
        if not os.path.isdir(base_path):
            makedirs(base_path)
        with open(path, 'w') as io:
            self.write(io)

    def remove(self):
        os.remove(self.path)

    def build(self):
        self.generate()
        path = self.path
        with current_context() as ctx:
            command = which(ctx.fallback(self.command, 'ninja_command', 'ninja'), True)
            verbose = ctx.get('verbose', False)
        args = [command, '-f', path]
        if verbose:
            args.append('-v')
        try:
            check_call(args)
        except CalledProcessError as e:
            return e.returncode
        return 0

    def clean(self):
        path = self.path
        if os.path.isfile(path):
            with current_context() as ctx:
                try:
                    args = [stringify(ctx.get('ninja_command', 'ninja')), '-f', path, '-t', 'clean', '-g']
                    check_call(args)
                except CalledProcessError as e:
                    return e.returncode
            self.remove()
        return 0

    def delegate(self):
        sys.exit(self.build())

    def write(self, io):
        with current_context() as ctx:
            columns = ctx.fallback(self.columns, 'ninja_file_columns', DEFAULT_COLUMNS)
            if (columns is not None) and (columns < _MINIMUM_COLUMNS):
                columns = _MINIMUM_COLUMNS
            strict = ctx.fallback(self.strict, 'ninja_file_columns_strict', False)
        with _Writer(io, columns, strict) as w:
            w.comment('Ninja file for %s' % self._project)
            w.comment('Generated by Ronin on %s' % datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC'))
            for rule_name, rule in self._project.phases.iteritems():
                self._write_rule(w, rule_name, rule)
                
    def _write_rule(self, w, phase_name, phase, all_phase_outputs={}):
        if phase_name in all_phase_outputs:
            # Already written!
            return

        # Input from other phases
        inputs_from_names = self._get_inputs_from_names(phase, all_phase_outputs, w)
        
        phase_outputs = []
        all_phase_outputs[phase_name] = phase_outputs
        
        rule_name = phase_name.replace(' ', '_')

        w.line()
        w.line('rule %s' % rule_name)
        
        description = stringify(phase.description)
        if description is not None:
            w.line('description = %s' % description, 1)

        w.line('command = %s' % phase.command, 1)
        
        if phase.command.depfile:
            w.line('depfile = $out.d', 1)
            
            deps = stringify(phase.command.deps)
            if deps is not None:
                w.line('deps = %s' % deps, 1)

        # Paths
        with current_context() as ctx:
            input_base = ctx.get('input_path')
            
            output_type = phase.command.output_type
            if output_type == 'object':
                output_base = ctx.get('object_path')
                if output_base is None:
                    output_base = join_path(self.base_path, ctx.get('object_path_relative'))
            elif output_type == 'binary':
                output_base = ctx.get('binary_path')
                if output_base is None:
                    output_base = join_path(self.base_path, ctx.get('binary_path_relative'))
        
        # Single output?
        if phase.output:
            output = join_path(output_base, phase.output)
        else:
            output = None

        # Inputs
        inputs = [join_path(input_base, v) for v in phase.inputs]
        for inputs_from_name in inputs_from_names:
            inputs += all_phase_outputs[inputs_from_name]
        inputs = dedup(inputs)

        # Extension
        extension = stringify(phase.command.output_extension)

        if output:
            # Single output
            w.line()
            
            output = change_extension(output, extension)
            if inputs:
                w.line('build %s: %s %s' % (_Writer.pathify(output), rule_name, ' '.join([_Writer.pathify(v) for v in inputs])))
            else:
                w.line('build %s: %s' % (_Writer.pathify(output), rule_name))
            phase_outputs.append(output)
        elif phase.inputs:
            # Multiple outputs
            w.line()
            
            prefix_length = len(input_base) + 1
            outputs = [join_path(output_base, change_extension(v[prefix_length:], extension)) for v in inputs]
            
            for index, output in enumerate(outputs):
                w.line('build %s: %s %s' % (_Writer.pathify(output), rule_name, _Writer.pathify(inputs[index])))
                phase_outputs.append(output)

    def _get_inputs_from_names(self, phase, all_phase_outputs, w):
        names = []
        for value in phase.inputs_from:
            if isinstance(value, Phase):
                name = self._project.get_phase_name(value)
                inputs_from = value
                if name is None:
                    raise AttributeError('inputs_from contains a phase that is not in the project')
            else:
                name = stringify(value)
                inputs_from = self._project.phases.get(name)
                if inputs_from is None:
                    raise AttributeError('inputs_from "%s" is not a phase in the project' % name)
            if inputs_from is phase:
                raise AttributeError('inputs_from contains self')

            names.append(name)
            self._write_rule(w, name, inputs_from, all_phase_outputs)
            
        return names

_MINIMUM_COLUMNS = 30 # lesser than this can lead to breakage
_INDENT = '  '

class _Writer(object):
    def __init__(self, io, columns, strict):
        self._io = io
        self._columns = columns
        self._strict = strict

    def __enter__(self):
        return self
    
    def __exit__(self, the_type, value, traceback):
        pass
    
    def line(self, line='', indent=0):
        indentation = _INDENT * indent
        if self._columns is None:
            self._io.write('%s%s\n' % (indentation, line))
        else:
            leading_space_length = len(indentation)
            broken = False
                
            while leading_space_length + len(line) > self._columns:
                width = self._columns - leading_space_length - 2
                
                # First try: find last un-escaped space within width 
                space = width
                while True:
                    space = line.rfind(' ', 0, space)
                    if (space < 0) or _Writer._is_unescaped(line, space):
                        break                

                # Second try (if non-strict): find first un-escaped space after width
                if (space < 0) and (not self._strict):
                    space = width - 1
                    while True:
                        space = line.find(' ', space + 1)
                        if (space < 0) or _Writer._is_unescaped(line, space):
                            break

                if space != -1:
                    # Break at space
                    self._io.write('%s%s $\n' % (indentation, line[:space]))
                    line = line[space + 1:]
                    if not broken:
                        # Indent                               
                        broken = True
                        indentation += _INDENT
                        leading_space_length += len(_INDENT)
                elif self._strict:
                    # Break anywhere
                    width += 1
                    self._io.write('%s%s$\n' % (indentation, line[:width]))
                    line = line[width:]
                else:
                    break

            self._io.write('%s%s\n' % (indentation, line))

    def comment(self, line):
        if self._columns is None:
            self._io.write('# %s\n' % line)
        else:
            width = self._columns - 2
            lines = wrap(line, width, break_long_words=self._strict, break_on_hyphens=False)
            for line in lines:
                self._io.write('# %s\n' % line)

    @staticmethod        
    def pathify(value):
        return value.replace('$ ', '$$ ').replace(' ', '$ ').replace(':', '$:')

    @staticmethod        
    def _is_unescaped(line, i):
        dollar_count = 0
        dollar_index = i - 1
        while (dollar_index > 0) and (line[dollar_index] == '$'):
            dollar_count += 1
            dollar_index -= 1
        return dollar_count % 2 == 0
