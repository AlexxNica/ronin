
from .contexts import current_context
from .phases import Phase
from .utils.paths import build_path, change_extension
from .utils.strings import stringify
from .utils.platform import which
from .utils.collections import dedup
from cStringIO import StringIO
from os import makedirs
from subprocess import check_call, CalledProcessError
from datetime import datetime
import sys, os

DEFAULT_NAME = 'build.ninja'
DEFAULT_COLUMNS = 100

def configure_ninja(ctx, command='ninja', file_name=DEFAULT_NAME, columns=DEFAULT_COLUMNS):
    ctx.ninja_command = which(command)
    ctx.ninja_file_name = file_name
    ctx.ninja_file_columns = columns

class NinjaFile(object):
    """
    Manages a `Ninja build system <https://ninja-build.org/>`__ file.
    """
    
    def __init__(self, project):
        self._project = project
    
    def __str__(self):
        io = StringIO()
        try:
            self.write(io)
            v = io.getvalue()
        finally:
            io.close()
        return v
    
    @property
    def base_path(self):
        with current_context() as ctx:
            return build_path(ctx.output_path, self._project.variant)

    @property
    def path(self):
        with current_context() as ctx:
            return build_path(self.base_path, ctx.get('ninja_file_name', DEFAULT_NAME))

    def generate(self):
        base_path = self.base_path
        path = self.path
        print "ronin: Generating '%s'" % path
        if not os.path.isdir(base_path):
            makedirs(base_path)
        with open(path, 'w') as io:
            self.write(io)

    def remove(self):
        os.remove(self.path)

    def build(self):
        self.generate()
        path = self.path
        with current_context() as ctx:
            try:
                args = [stringify(ctx.get('ninja_command', 'ninja')), '-f', path]
                if ctx.get('verbose', False):
                    args.append('-v')
                check_call(args)
            except CalledProcessError as e:
                return e.returncode
        return 0

    def clean(self):
        path = self.path
        if os.path.isfile(path):
            with current_context() as ctx:
                try:
                    args = [stringify(ctx.get('ninja_command', 'ninja')), '-f', path, '-t', 'clean', '-g']
                    check_call(args)
                except CalledProcessError as e:
                    return e.returncode
            self.remove()
        return 0

    def delegate(self):
        sys.exit(self.build())

    def write(self, io):
        self._write(io, '# Ninja file for %s' % self._project)
        self._write(io, '# Generated by Ronin on %s' % datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC'))
        for rule_name, rule in self._project.phases.iteritems():
            self._write_rule(io, rule_name, rule)
                
    def _pathify(self, value):
        return value.replace(' ', '$ ')
    
    def _write_rule(self, io, phase_name, phase, all_phase_outputs={}):
        if phase_name in all_phase_outputs:
            # Already written!
            return

        # Input from other phases
        inputs_from_names = self._get_inputs_from_names(phase, all_phase_outputs, io)
        
        phase_outputs = []
        all_phase_outputs[phase_name] = phase_outputs
        
        rule_name = phase_name.replace(' ', '_')

        self._write(io)
        self._write(io, 'rule %s' % rule_name)
        
        description = stringify(phase.description)
        if description is not None:
            self._write(io, '  description = %s' % description)

        self._write(io, '  command = %s' % phase.command)
        
        if phase.command.depfile:
            self._write(io, '  depfile = $out.d')
            
            deps = stringify(phase.command.deps)
            if deps is not None:
                self._write(io, '  deps = %s' % deps)

        # Paths
        with current_context() as ctx:
            input_base = ctx.get('input_path')

            object_base = ctx.get('object_path')
            if object_base is None:
                object_base = build_path(self.base_path, ctx.get('object_path_relative'))
            
            binary_base = ctx.get('binary_path')
            if binary_base is None:
                binary_base = build_path(self.base_path, ctx.get('binary_path_relative'))
        
        # Single output?
        if phase.output:
            output = build_path(binary_base, phase.output)
        else:
            output = None

        # Inputs
        inputs = [build_path(input_base, v) for v in phase.inputs]
        for inputs_from_name in inputs_from_names:
            inputs += all_phase_outputs[inputs_from_name]
        inputs = dedup(inputs)

        if output:
            # Single output
            self._write(io)
            if inputs:
                self._write(io, 'build %s: %s %s' % (self._pathify(output), rule_name, ' '.join([self._pathify(v) for v in inputs])))
            else:
                self._write(io, 'build %s: %s' % (self._pathify(output), rule_name))
            phase_outputs.append(output)
        elif phase.inputs:
            # Multiple outputs
            self._write(io)
            
            prefix_length = len(input_base) + 1
            extension = stringify(phase.command.output_extension)
            outputs = [build_path(object_base, change_extension(v[prefix_length:], extension)) for v in inputs]
            
            for index, output in enumerate(outputs):
                self._write(io, 'build %s: %s %s' % (self._pathify(output), rule_name, self._pathify(inputs[index])))
                phase_outputs.append(output)

    def _write(self, io, line=''):
        with current_context() as ctx:
            columns = ctx.get('ninja_file_columns', DEFAULT_COLUMNS)
        if (columns > _MINIMUM_COLUMNS) and (not line.startswith('#')):
            while line is not None:
                if len(line) > columns - 1:
                    remainder = line[columns - 1:]
                    line = line[:columns - 1]
                    io.write('%s$\n' % line)
                    line = remainder
                else:
                    io.write('%s\n' % line)
                    line = None
        else:
            io.write('%s\n' % line)

    def _get_inputs_from_names(self, phase, all_phase_outputs, io):
        names = []
        for value in phase.inputs_from:
            if isinstance(value, Phase):
                name = None
                inputs_from = value
                for k, v in self._project.phases.iteritems():
                    if v is value:
                        name = k
                        break
                if name is None:
                    raise AttributeError('inputs_from contains a phase that is not in the project')
            else:
                name = stringify(value)
                inputs_from = self._project.phases.get(name)
                if inputs_from is None:
                    raise AttributeError('inputs_from "%s" is not a phase in the project' % name)

            if inputs_from is phase:
                raise AttributeError('inputs_from contains self')

            names.append(name)
            self._write_rule(io, name, inputs_from, all_phase_outputs)
            
        return names

_MINIMUM_COLUMNS = 30 # lesser than this can lead to breakage
