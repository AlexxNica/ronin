
from .contexts import current_context
from .phases import Phase
from .utils.paths import build_path, change_extension
from .utils.strings import stringify
from .utils.platform import which
from .utils.collections import dedup
from cStringIO import StringIO
from os import makedirs
from subprocess import check_call, CalledProcessError
from datetime import datetime
from textwrap import wrap
import sys, os

# See:
# https://ninja-build.org/manual.html#_ninja_file_reference
# https://github.com/ninja-build/ninja/blob/master/misc/ninja_syntax.py

DEFAULT_NAME = 'build.ninja'
DEFAULT_COLUMNS = 100

def configure_ninja(ctx, command='ninja', file_name=DEFAULT_NAME, columns=DEFAULT_COLUMNS):
    ctx.ninja_command = which(command)
    ctx.ninja_file_name = file_name
    ctx.ninja_file_columns = columns

class NinjaFile(object):
    """
    Manages a `Ninja build system <https://ninja-build.org/>`__ file.
    """
    
    def __init__(self, project):
        self._project = project
    
    def __str__(self):
        io = StringIO()
        try:
            self.write(io)
            v = io.getvalue()
        finally:
            io.close()
        return v
    
    @property
    def base_path(self):
        with current_context() as ctx:
            return build_path(ctx.output_path, self._project.variant)

    @property
    def path(self):
        with current_context() as ctx:
            return build_path(self.base_path, ctx.get('ninja_file_name', DEFAULT_NAME))

    def generate(self):
        base_path = self.base_path
        path = self.path
        print "ronin: Generating '%s'" % path
        if not os.path.isdir(base_path):
            makedirs(base_path)
        with open(path, 'w') as io:
            self.write(io)

    def remove(self):
        os.remove(self.path)

    def build(self):
        self.generate()
        path = self.path
        with current_context() as ctx:
            try:
                args = [stringify(ctx.get('ninja_command', 'ninja')), '-f', path]
                if ctx.get('verbose', False):
                    args.append('-v')
                check_call(args)
            except CalledProcessError as e:
                return e.returncode
        return 0

    def clean(self):
        path = self.path
        if os.path.isfile(path):
            with current_context() as ctx:
                try:
                    args = [stringify(ctx.get('ninja_command', 'ninja')), '-f', path, '-t', 'clean', '-g']
                    check_call(args)
                except CalledProcessError as e:
                    return e.returncode
            self.remove()
        return 0

    def delegate(self):
        sys.exit(self.build())

    def write(self, io):
        with _Writer(io) as w:
            w.comment('Ninja file for %s' % self._project)
            w.comment('Generated by Ronin on %s' % datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC'))
            for rule_name, rule in self._project.phases.iteritems():
                self._write_rule(w, rule_name, rule)
                
    def _write_rule(self, w, phase_name, phase, all_phase_outputs={}):
        if phase_name in all_phase_outputs:
            # Already written!
            return

        # Input from other phases
        inputs_from_names = self._get_inputs_from_names(phase, all_phase_outputs, w)
        
        phase_outputs = []
        all_phase_outputs[phase_name] = phase_outputs
        
        rule_name = phase_name.replace(' ', '_')

        w.line()
        w.line('rule %s' % rule_name)
        
        description = stringify(phase.description)
        if description is not None:
            w.line('description = %s' % description, 1)

        w.line('command = %s' % phase.command, 1)
        
        if phase.command.depfile:
            w.line('depfile = $out.d', 1)
            
            deps = stringify(phase.command.deps)
            if deps is not None:
                w.line('deps = %s' % deps, 1)

        # Paths
        with current_context() as ctx:
            input_base = ctx.get('input_path')

            object_base = ctx.get('object_path')
            if object_base is None:
                object_base = build_path(self.base_path, ctx.get('object_path_relative'))
            
            binary_base = ctx.get('binary_path')
            if binary_base is None:
                binary_base = build_path(self.base_path, ctx.get('binary_path_relative'))
        
        # Single output?
        if phase.output:
            output = build_path(binary_base, phase.output)
        else:
            output = None

        # Inputs
        inputs = [build_path(input_base, v) for v in phase.inputs]
        for inputs_from_name in inputs_from_names:
            inputs += all_phase_outputs[inputs_from_name]
        inputs = dedup(inputs)

        if output:
            # Single output
            w.line()
            if inputs:
                w.line('build %s: %s %s' % (_Writer.pathify(output), rule_name, ' '.join([_Writer.pathify(v) for v in inputs])))
            else:
                w.line('build %s: %s' % (_Writer.pathify(output), rule_name))
            phase_outputs.append(output)
        elif phase.inputs:
            # Multiple outputs
            w.line()
            
            prefix_length = len(input_base) + 1
            extension = stringify(phase.command.output_extension)
            outputs = [build_path(object_base, change_extension(v[prefix_length:], extension)) for v in inputs]
            
            for index, output in enumerate(outputs):
                w.line('build %s: %s %s' % (_Writer.pathify(output), rule_name, _Writer.pathify(inputs[index])))
                phase_outputs.append(output)

    def _get_inputs_from_names(self, phase, all_phase_outputs, w):
        names = []
        for value in phase.inputs_from:
            if isinstance(value, Phase):
                name = self._project.get_phase_name(value)
                inputs_from = value
                if name is None:
                    raise AttributeError('inputs_from contains a phase that is not in the project')
            else:
                name = stringify(value)
                inputs_from = self._project.phases.get(name)
                if inputs_from is None:
                    raise AttributeError('inputs_from "%s" is not a phase in the project' % name)
            if inputs_from is phase:
                raise AttributeError('inputs_from contains self')

            names.append(name)
            self._write_rule(w, name, inputs_from, all_phase_outputs)
            
        return names

_MINIMUM_COLUMNS = 30 # lesser than this can lead to breakage
_INDENT = '  '

class _Writer(object):
    def __init__(self, io):
        self._io = io

    def __enter__(self):
        return self
    
    def __exit__(self, type, value, traceback):
        pass
    
    def line(self, line='', indent=0):
        indentation = _INDENT * indent
        columns, strict = self._columns
        if columns is None:
            self._io.write('%s%s\n' % (indentation, line))
        else:
            leading_space_length = len(indentation)
            broken = False
                
            while leading_space_length + len(line) > columns:
                width = columns - leading_space_length - 2
                
                # First try: find last un-escaped space within width 
                space = width
                while True:
                    space = line.rfind(' ', 0, space)
                    if (space < 0) or _Writer._is_unescaped(line, space):
                        break                

                # Second try (if non-strict): find first un-escaped space after width
                if (space < 0) and (not strict):
                    space = width - 1
                    while True:
                        space = line.find(' ', space + 1)
                        if (space < 0) or _Writer._is_unescaped(line, space):
                            break

                if space != -1:
                    # Break at space
                    self._io.write('%s%s $\n' % (indentation, line[:space]))
                    line = line[space + 1:]
                    if not broken:
                        # Indent                               
                        broken = True
                        indentation += _INDENT
                        leading_space_length += len(_INDENT)
                elif strict:
                    # Break anywhere
                    width += 1
                    self._io.write('%s%s$\n' % (indentation, line[:width]))
                    line = line[width:]
                else:
                    break

            self._io.write('%s%s\n' % (indentation, line))

    def comment(self, line):
        columns, strict = self._columns
        if columns is None:
            self._io.write('# %s\n' % line)
        else:
            width = columns - 2
            lines = wrap(line, width, break_long_words=strict, break_on_hyphens=False)
            for line in lines:
                self._io.write('# %s\n' % line)

    @staticmethod        
    def pathify(value):
        return value.replace('$ ', '$$ ').replace(' ', '$ ').replace(':', '$:')

    @property
    def _columns(self):
        with current_context() as ctx:
            columns = ctx.get('ninja_file_columns', DEFAULT_COLUMNS)
            strict = ctx.get('ninja_file_columns_strict', False)
        return columns if columns >= _MINIMUM_COLUMNS else None, strict

    @staticmethod        
    def _is_unescaped(line, i):
        dollar_count = 0
        dollar_index = i - 1
        while (dollar_index > 0) and (line[dollar_index] == '$'):
            dollar_count += 1
            dollar_index -= 1
        return dollar_count % 2 == 0
